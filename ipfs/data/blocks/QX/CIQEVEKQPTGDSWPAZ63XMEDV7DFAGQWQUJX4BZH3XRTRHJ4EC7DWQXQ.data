
Ô]Á]<h1 id="h1-an-almost-working-cryptocurrency-built-from-scratch-in-24-hours"><a name="An almost-working cryptocurrency built from scratch in 24 hours" class="reference-link"></a><span class="header-link octicon octicon-link"></span>An almost-working cryptocurrency built from scratch in 24 hours</h1><p>On Saturday and Sunday, February 17th and 18th, 2018, a few members of CAT Club attended CodeDay Chicago with the goal of building a working cryptocurrency completely from scratch in just 24 hours.</p>
<p>Did we succeed? Almost. And that goes a very long way when dealing with a new, evolving technology like the blockchain. Here‚Äôs our story.</p>
<hr>
<p>Our area of focus this year has been on the blockchain. Due to the tremendous financial success of cryptocurrencies and growth in popularity of blockchain technology as a whole last year, demand for blockchain engineers is rapidly growing; in fact, according to TechCrunch, blockchain-related jobs are the second-fastest growing in today‚Äôs labor market; there are now 14 job openings for every one blockchain developer. We believe it is important for us as students to be at the forefront of this rapidly growing industry that is changing the world.</p>
<p>The problem, however, with leading the evolution of an impactful piece of technology is that it is scary‚Ää‚Äî‚Ääespecially for high school students and new developers‚Äî because anything new is naturally intimidating. Blockchain technology is particularly scary because simply understanding it has a steep learning curve, much less programming one from scratch. Without previous knowledge of peer-to-peer networking and public/private key cryptography, grasping the concepts of the blockchain and distributed ledgers is very difficult, since the nature of a distributed ledger requires a peer-to-peer network and elliptic curve cryptography in order to function.</p>
<p>Our mission at CodeDay was to take the leap of faith, far outside any of our comfort zones, and just start building with one very simple goal in mind: be able to send a coin from one computer to another computer by any means necessary. We knew from the get-go that building a working cryptocurrency from scratch was a very ambitious goal since it is new to everyone, including us. Although our ultimate goal was to make it work, our true goal was to shorten the gap between not understanding the concept at all and knowing it well enough to build it. Working on this project not only greatly improved each of our understandings of how a blockchain works behind the scenes, it also forced us to learn how to work efficiently in a team. We planned each step of the way before writing any code, and we divided and conquered certain aspects of the blockchain in order to move more efficiently. Working in a group on a project like this in such a short time frame is something that none of us have ever done before, so doing this was also great experience for each of us in that area.</p>
<h2 id="h2-how-does-our-cryptocurrency-work-"><a name="How Does Our Cryptocurrency Work?" class="reference-link"></a><span class="header-link octicon octicon-link"></span>How Does Our Cryptocurrency Work?</h2><h3 id="h3-blockchain"><a name="Blockchain" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Blockchain</h3><p>We created two classes to create and handle the blockchain: Block and Blockchain. The Block class simply contains the parameters for creating a block, as well as a few functions for handling certain aspects of the block. The Blockchain class gives the responsibility of providing a blockchain to the network and contains a few functions to manage it, such as creating the genesis block, searching for a block in the blockchain, getting the transactions in a block, etc. It was probably the most straightforward part of our project.</p>
<h3 id="h3-wallet"><a name="Wallet" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Wallet</h3><p>The wallet, much like the Block and Blockchain, was pretty straightforward. It had only two simple tasks: be able to generate a wallet‚Äôs private/public keys and a wallet address, and to be able to use that information to create and sign transactions. We didn‚Äôt focus on interacting with the network here; instead, we created and wrote all the necessary info about local wallets and any transactions that might be created to json files, which the network could then read from when it needed to and do what it needed to do to get any transactions and signatures on the network.</p>
<p>The only part of the wallet that we did not code ourselves was the elliptic curve cryptography. The math behind elliptic curve cryptography is far too advanced for any of us to understand, and since we weren‚Äôt shooting for customizability or even practical usability with our project, we used Python‚Äôs ecdsa (elliptic curve digital signature algorithm) library to handle everything that requires an elliptic curve, such as wallet address/key generation.</p>
<p>It is also important to note that in our implementation, because we were short on time due to some problems we encountered, we decided we didn‚Äôt have enough time to worry about properly verifying transactions, so we didn‚Äôt write anything that verifies the transactions. We know that this makes the our cryptocurrency completely impractical, but again, we weren‚Äôt shooting for practicality here because we wanted, above all, to simply be able to send something from one computer to another computer on a blockchain, so we decided it wasn‚Äôt absolutely necessary. I regret it and I really wish we had more time to get that sorted out.</p>
<h3 id="h3-control"><a name="Control" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Control</h3><p>We decided to take an approach to controlling our cryptocurrency that we haven‚Äôt seen anyone else do: Python argparse. We started by creating a list of all of the commands we wanted the user to be able to do: update blocks, get block (by index or by hash), send some amount to an address, etc., then we created custom actions that parse and handle each of those actions when they are run in the console. We believe this is a very easy way to control the program given the fact that we didn‚Äôt have enough time to write a proper UI. We used Python argparse to create flags that served as commands and that allowed some arguments to follow them for clarification. It worked out very well!<br>An example of a command that gets the balance of a particular wallet.<br>walletinfo.json, which stores all of the important info of the particular wallet ‚Äúaddr‚Äù</p>
<p>The main ‚Äúhcoin.py‚Äù file is run along with the particular command that the user wants to be carried out. Only the part of hcoin.py that corresponds to the flag specified by the user is run. In this way, hcoin.py serves only as the control of the program.</p>
<h3 id="h3-ui"><a name="UI" class="reference-link"></a><span class="header-link octicon octicon-link"></span>UI</h3><p>It‚Äôs also probably worth mentioning that we started working on a web interface for this project that would serve as a hybrid of a block explorer and an interface that showed things such as your CPU performance and some hard drive statistics while mining. We abandoned this a little bit into the project because we realized that actually making the cryptocurrency was a far more difficult and important task than writing a web interface to complement it, however nice it might have looked.</p>
<h3 id="h3-network"><a name="Network" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Network</h3><p>Since none of us know enough peer-to-peer networking to make our own peer-to-peer network for this project, we decided to use Python Flask as our network and modify it to make it peer-to-peer. Flask wasn‚Äôt built to be a peer-to-peer framework, so this proved to be a very inefficient (and, if this coin were to be actually used, very insecure) way of making our peer-to-peer network that ended up being a major bottleneck for us in the future. Nevertheless, we managed to make it work with Flask a lot better than we thought.</p>
<p>There is one Flask instance in the entire program, and that is in the miner.py file. This means that before you can actually get on the network, you must run the miner.py file and start mining, because the file also has everything that handles the network.</p>
<p>In order to be able to communicate important network info between the miner and any other file (such as the wallet to tell the miner when it needed it to post a transaction to the blockchain), we also created a Propagator class. The Propagator essentially uses Python requests to post certain HTTP requests that the Flask instance in the miner can then pick up on and handle appropriately.<br>A few functions of the Propagator class</p>
<h3 id="h3-this-is-where-the-problems-begin"><a name="This is where the problems begin" class="reference-link"></a><span class="header-link octicon octicon-link"></span>This is where the problems begin</h3><p>The problems started coming in later, when it was time to make our program be able to actually send one coin from one computer to another computer on the network. All of the inefficiencies in our code and file structure, on top of our general lack of Python knowledge, led to it all falling apart at the end.</p>
<p>What we believe happened was that both the miner file and the hcoin file were attempting to access the same things, but were trying to access different chunks of memory, so the blockchain, among many things, that the hcoin file saw was not the blockchain that the miner file saw. We couldn‚Äôt get the different files to agree on what the blockchain really was, and because of this, we couldn‚Äôt send anything over the network. We scrambled to try to use multiprocessing (something none of us were familiar with at all) to fix this at the end, but ultimately we could not get it solved by presentation time.<br>What our project says about blockchain technology as a whole</p>
<p>We had almost everything working by presentation time. Our only problem was the inability to actually send anything over the network. In the grand scheme things, our error was very insignificant. We failed, but we came amazingly close to succeeding.</p>
<p>Because the blockchain is such a new technology, many people, especially younger developers, shy away from it. They feel that it is too complicated‚Ää‚Äî‚Ääand, in a way, they‚Äôre sort of right. They‚Äôre right in saying that the blockchain is a difficult piece of technology to wrap your head around. But once you wrap your head around it, the possibilities are endless. If three 15 and 16 year old high school students from Indiana can almost create one entirely from scratch in less than 24 hours without having ever done anything like it before and in a language none of them were really familiar with, I have no doubt everyone else can do it, including you.</p>
<p>If you were ever thinking of getting into the blockchain game, now is the best time to do it. Take the leap of faith and try making a blockchain yourself. Or, at the very least, educate yourself on how it all works and how to develop on a blockchain with Ethereum. If you start now, you can be a pioneer in this new technological revolution by helping the greater blockchain community solve the many problems that need to be solved before it is ready to become the basis of the ‚ÄúInternet 3.0‚Äù and usher in the new age of security and anonymity that it promises to usher in.</p>
<p>Final note: If you‚Äôd like to help us finish what we started and create an entry point for future blockchain engineers to learn all about the blockchain through a simple implementation, you can contribute to our repository. Beware, though: we broke a lot of things at the end in a desperate attempt to fix things! You can get to it by clicking here.</p>
Á]